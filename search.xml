<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「置顶」Java八股+算法博客汇总]]></title>
    <url>%2F2022%2F10%2F11%2F%E3%80%8C%E7%BD%AE%E9%A1%B6%E3%80%8DJava%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[「秋招」2022年秋招寒冬]]></title>
    <url>%2F2022%2F10%2F11%2F%E3%80%8C%E7%A7%8B%E6%8B%9B%E3%80%8D2022%E5%B9%B4%E7%A7%8B%E6%8B%9B%E5%AF%92%E5%86%AC%2F</url>
    <content type="text"><![CDATA[用友软件开发：https://www.nowcoder.com/discuss/1051551 中国系统后端开发：https://www.nowcoder.com/discuss/1051949]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「暑期实习」2022-亚马逊+嘉实基金+阿里云]]></title>
    <url>%2F2022%2F10%2F11%2F%E3%80%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E3%80%8D2022-%E4%BA%9A%E9%A9%AC%E9%80%8A-%E5%98%89%E5%AE%9E%E5%9F%BA%E9%87%91-%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[亚马逊SDE：https://www.nowcoder.com/discuss/854294 嘉实基金软件开发：https://www.nowcoder.com/discuss/958879 阿里云弹性计算Java后端：https://www.nowcoder.com/discuss/936610]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础 | == 和 equals 和 hashCode]]></title>
    <url>%2F2022%2F10%2F11%2FJava%E5%9F%BA%E7%A1%80-%E5%92%8C-equals-%E5%92%8C-hashCode%2F</url>
    <content type="text"><![CDATA[== 和 equals() equals() 和 hashCode() == 和 equals() == 基本数据类型比较的是值，只要值一样就返回true，和类型无关。 引用数据类型比较的是对象的内存地址，看两个引用是否指向同一个对象实体。 equals() 情况1：equals() 方法没有被重写，仍然默认使用==。 情况2：equals() 方法被重写，则比较的是两个对象的内容。通常情况下，重写equals() 方法就是比较类中相应属性是否都相等。 重写 equals() 方法的步骤 判断形参 == this，是则返回true。 判断形参 instanceof 当前对象的类名，是则把形参强转为当前对象的类的对象，依次判断相应属性是否相等。 如果相应属性是基础数据类型，用 == 直接判断，否则继续使用 equals() 判断。12345678910class Solution &#123; public static void main(String[] args) &#123; int i = 10; double j = 10.0; char c = 10; System.out.println(i == j); // true System.out.println(i == c); // true System.out.println(j == c); // true &#125;&#125; equals() 和 hashCode()（一）equals() 和 hashCode() 本身都是 Object 类中的方法 Object.equals() 方法比较对象的内存地址是否相等。 Object.hashCode() 是native方法，大部分情况返回对象的内存地址，具体还要取决于运行时库和JVM的具体实现。1234567package java.lang;public class Object &#123; public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125;&#125; （二）自定义类中重写 equals() 和 hashCode() 方法 String 类已经重写了这两个方法。 重写的 equals() 方法用来判断两个对象是否相等。 重写的 hashCode() 方法的作用是获取哈希码，实际上是返回一个int整数，确定该对象在哈希表中的索引位置。 如果两个对象的 equals() 返回true，它们的 hashCode() 值一定相同。 如果两个对象 hashCode() 相等，它们的 equals() 并不一定返回true。hashCode() 只是用来缩小查找成本，会有哈希碰撞的情况。 1234567891011121314151617181920212223242526272829303132333435363738package java.lang;public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125;&#125; （三）只要重写了 equals()，必须重写 hashCode() 的场景和原因： Set存储的自定义对象必须重写这两个方法。 如果自定义对象作为Map的key，必须重写这两个方法。 如果自定义对象不重写 hashCode()，那就自动调用 Object 的 hashCode() 方法，大部分情况返回的是对象的内存地址，违反了“如果两个对象的 equals() 返回true，它们的 hashCode() 值一定相同”原则。 （四）重写 hashCode() 方法的原则 在程序运行时，同一个对象多次调用 hashCode() 应该返回相同的值。 当两个对象的 equals() 方法返回true时，hashCode() 的返回值也应该相等。 对象中用作 equals() 方法比较的属性，都应该用来计算 hashCode 值。比如下面的 hashCode() 方法中应该用到 name 和 address 两个属性。 123456789101112131415161718public class Animal &#123; private String name; private String address; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Animal animal = (Animal) o; return Objects.equals(name, animal.name) &amp;&amp; Objects.equals(address, animal.address); &#125; @Override public int hashCode() &#123; return Objects.hash(name, address); &#125;&#125; （五）为什么调用IDE工具自动重写这俩方法时有31这个数字 选择系数时要选择尽量大的系数，减少冲突 31只占用5bits，相乘造成数据溢出的概率比较小 31可以由 i*31==(i&lt;&lt;5)-1 来表示，现在很多虚拟机里面都有做相关优化，提高算法效率 31是一个素数，如果用一个数字来乘以这个素数，最终出来的结果只能被素数本身和被乘数还有1来整除，减少冲突]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快慢指针-判断链表中是否有环]]></title>
    <url>%2F2021%2F04%2F15%2F%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B9%8B%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[力扣： 141. 环形链表 这是面试高频题，典型的快慢指针题目——快指针每次走两步，慢指针每次走一步，快慢指针相遇的话，就说明链表中有环。 今天同事说，有次他面试的时候，面试官问他：如果快指针每次走三步，还能不能和慢指针相遇。 挺有意思的一个问题，然后同事给出了一个证明： 代码： 12345678910111213class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode *fast = head; ListNode *slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next-&gt;next; if(slow == fast) return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「日常实习」度小满Java后端实习]]></title>
    <url>%2F2021%2F03%2F18%2F%E3%80%8C%E9%9D%A2%E8%AF%95%E3%80%8D%E5%BA%A6%E5%B0%8F%E6%BB%A1Java%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JD 一面2021.3.11 一面 周四 没有自我介绍，上来就问问题 Java的集合简单介绍一下？答：List存储有序可重复数据、Set存储无序不可重复数据、Map存储键值对。List接口的主要实现类有… 面试官打断，说你已经说的挺清楚了，问：如果用ArrayList存储一亿个数据有什么缺点？答：查询慢（不知道存储海量数据会对ArrayList的查询性能造成影响吗？？？）。ArrayList的空间浪费主要体现在list列表的结尾预留一定的容量空间（ArrayList容量不够时会扩容到原来的1.5倍）。插入和删除元素效率比较低（在最后插入或删除除外）。【网上查的答案：ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，如果明确 1亿条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量，这样就可以提高效率了】 ArrayList可以在中间插入元素吗，比如长度为10的ArrayList在第五个位置插入一个元素，可以吗？答：可以。 常量和变量是什么？答：（1）常量在整个程序中只能被赋值一次，在程序运行过程不会改变，用final关键字定义(final int N=10; 常量的命名规则是一般是用大写英文字母表示，如final double PI=3.14;)。（2）变量分为成员变量和局部变量（2.1）在类体中所定义的变量为成员变量，成员变量在整个类中都有效。类的成员变量又分为两种：静态变量和实例变量。（2.2）在类的方法内声明的变量为局部变量，包括方法的参数都属于局部变量，只在当前定义的方法内有效,不能用于类的其他方法中。 类的变量的初始化默认值是在什么时候？ 了解双亲委派模型吗？答：双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载 类加载的几个阶段说一下？答：加载、链接（验证、准备、解析）、初始化。 类的信息加载到JVM的哪个区域？答：我想想 你知道JVM里面有几个区域吗？答：线程共享的是：堆、方法区（jdk1.8后被元空间取代）；线程私有的是：程序计数器、java虚拟机栈、本地方法栈。 回到上面的问题，类的信息加载到JVM的哪个区域？答：类的信息加载到JVM的方法区，就是jdk1.8后的元空间。 看看简历，你在百度实习主要做的什么？你写的代码实现什么功能？答：xxx然后又问了几个前端的问题，我都不大懂。 前端你会一点吗，比如css、标签这些？答：会一些html、css的东西。 json是什么？答：JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。 写一个编程题，判断一个文件里面是否包括hello字符串。一些api记不住没关系，大概写出来思路就行，主要看你代码规范和思路。答：用的字符流FileReader 写完后大致说了一下思路，接下来就是面试官针对代码提问。 第四行用的FileReader，这个字节流字符流有什么区别？答：字符流处理文本文件（.txt .java .c .cpp等）；字节流 InputStream、OutputStream处理非文本文件（.ppt .mp4 .jpg .doc等）。 第七行，如果这个文件不确定怎么办？答：在键盘输入文件名后用Scan接收，或者把这个部分代码拿出来到一个方法里面，文件名设为形参，调用这个方法时传入。 如果这个文件不存在怎么办？答：抛出异常，或者提示不存在该文件。 第11行为什么是5？答：其他长度也行，这个数值越大读取的越快。 第10行写注释了啊，很好不错。第19行关闭了io流，很好。 如果这个文件特别特别大上百个G没法一下子读完怎么办？答：把第21行放到try里面，一边读取文件一边判断。 这个思路很好。答：我暂时没有其他思路了。 你有什么问题问我吗？答：没有了，谢谢您。 面试官最后问一周能实习几天，然后简单说了一下百度跟度小满的关系就像阿里巴巴跟蚂蚁金服，度小满是从百度金融那块分出去的，工作量比较大，会加班，毕竟度小满如果有什么问题会影响百度的股票。公司有大小周，一般每个月的偶数周，第二周或第四周周六会加班，当然这个加班会给工资的。你之前在百度实习也知道百度上班下班时间，度小满也一样十点半上班不要求打卡。 一个小时之后hr打电话约了二面时间。 总结：整体来说比较顺利，主要问了Java集合和jvm内存区域以及类加载过程。除此之外主要问了下之前在百度测开实习的经历，不过我前端基础比较差，问的前端的问题都不怎么会。编程题没想到是io流的，没考算法。总体来说问的问题比较细节化，八股文不算多吧，面试官针对一个问题会扩展，比如会问如果数据量特别多要怎么办。 二面2021.3.16 周二 20：00 二面 本来约的昨天晚上七点，结果hr打电话说面试官太忙了，改成了今天晚上七点，结果六点五十hr打电话说面试官太忙了，改成了今天晚上八点。 面了大概四十五分钟，先开始是自我介绍。 先问了下未来职位意向。 除了Java，会其他编程语言吗？ 先整体说一下Java的内容？答：从Java基本数据机构，到面向对象，封装性继承性多态性，线程，IO流，反射，集合，spring框架等等。 了解JVM吗？答：了解jvm的内存结构、类加载过程、垃圾回收算法。 说一下jvm的内存结构。答：方法区（元空间）、堆、程序计数器、本地方法栈、java虚拟机栈。 垃圾回收主要作用于哪一部分？答：堆和方法区。 怎么判断一个对象是否死亡？答：引用计数法、可达性分析。 标记清除法的缺点是什么？答：产生内存碎片。 Java就到这里，数据库用过什么？答：MySQL。 像java一样先整体介绍一下MySQL吧。答：CUID，索引（B+树），事务（ACID特征），事务隔离级别，水平分表垂直分库。 水平分表的规则是什么？答：具体的规则忘了，就举了一个例子。 垂直分库用过吗？答：没有实现过。 数据库的底层实现了解吗？答：我只了解innodb。 问了一下innodb。答：innodb是事务型存储引擎，支持事务。 MyISAM和InnoDB区别 ？答：MyISAM是5.几之前MySQL默认的数据引擎。innodb支持外键，MyISAM不支持。MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快。 MyISAM支持什么锁，innodb呢？答：MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row- level locking)和表级锁,默认为行级锁。 下面聊一下网络。说一下在浏览器中输入url地址 ，然后网页显示出来的过程。答：整体来说分为几个阶段：1. DNS解析 2. TCP连接 3. 发送HTTP请求 4. 服务器处理请求并返回HTTP报文 5. 浏览器解析渲染⻚面 6. 连接结束 整体是这样，能不能具体说一下后端的处理过程。答：没明白面试官问的点，就说了一下http、https、建立tcp连接等等。后来面试官说问的是后端数据处理controller层、dao层这些。 最后写个代码吧，输入一个int型的数，判断它是不是3幂数。先讲一下思路，然后用java写一下代码。 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; if(solution(27)) System.out.println(&quot;yes!&quot;); else System.out.println(&quot;no!&quot;); &#125; public static boolean solution(int n) &#123; if(n == 1) return true; while(n &gt;= 3)&#123; //n对3取余，结果不为0 if(n % 3 != 0) return false; //n对3取余，结果为0 n /= 3; if(n == 3) return true; &#125; return false; &#125;&#125; 其实编程题完了之后面试官还说了挺多，包括说了下度小满的加班，问我实习有什么目的吗，在度小满能学到金融类的知识等等。面试的时候基本没有问框架、高并发、Linux的问题。 面试完已经快九点了，第二天上午十点hr就打电话道歉说昨天这么晚才面试，然后恭喜我二面通过，约了三面的时间，说三面不会问什么技术问题了。 三面2021.3.18 周四 15：00 三面 三面应该是经理面吧，主要在聊之前的实习经历、学校的情况，没有技术性的问题。 结果：面试完立马hr打电话给了结果 总之，度小满的hr和面试官都超级nice，回答不上来的问题会提示，我最后提的问题也都会耐心详细解释，很好的一次体验。后来入职后感觉团队工作氛围特别好，同事友善，下班也比较早，leader特别好，总之就是很好很好 2022.1 更： 把实习的经历做成了一个视频： https://www.bilibili.com/video/BV1FU4y1M73P?share_source=copy_web 欢迎三连哦！]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
      <tags>
        <tag>度小满</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac如何创建虚拟机 | VirtualBox + Vagrant | Multipass]]></title>
    <url>%2F2021%2F02%2F17%2Fmac%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[记录在Mac上安装虚拟机的过程。 1 安装软件1.1 VirtualBox VirtualBox 是由德国 Innotek 公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。VirtualBox 和 VMWare 是同类型软件，开源，可以在当前运行的系统上构建出一台虚拟电脑。 下载主程序： https://www.virtualbox.org/wiki/Downloads 下拉网页下载扩展包，有些高级特性，比如 USB 3.0 等需要扩展包的支持： 在 Windows 系统中使用 VirtualBox 需开机进入BIOS开启CPU虚拟化。 Mac则不同： 首先看硬件是否支持，如果输出中有【VMX】，说明支持： 1sysctl -a | grep machdep.cpu.features 然后再次输入，如果输出为1那么说明支持【VT-x VT-d】（不支持的话只能更新你的系统了）： 1sysctl kern.hv_support 如果无法开启，那么要设置，输入下面的命令，输入密码，即可设置好，重启Mac就可以打开： 1sudo nvram boot-args=”kext-dev-mode=1 1.2 Vagrant vagrant是一个工具，用于创建和部署虚拟化开发环境的。VirtualBox会开放一个创建虚拟机的接口，Vagrant会利用这个接口创建虚拟机，并且通过Vagrant来管理，配置和自动安装虚拟机。 下载链接： https://www.vagrantup.com/downloads Vagrant 是没有图形界面的，所以安装完成后也没有桌面快捷方式。可以在终端执行 vagrant version 检查是否安装成功： 2 创建虚拟机2.1 下载虚拟机基础镜像方法一：官方下载镜像 使用 Vagrant 创建虚拟机时，需要指定一个镜像，也就是 box。开始这个 box 不存在，所以 Vagrant 会先从网上下载，然后缓存在本地目录中。 Vagrant 官方镜像仓库： https://app.vagrantup.com/boxes/search 在镜像仓库中选择要下载的版本，点击进入后可以看到如下图所示的how to use： 在终端执行： 这个命令为我们在当前目录生成一个 Vagrantfile，下面的所有操作都是在该文件夹下完成的。 方法二：其他方式下载.box 如果官方默认下载比较慢，可以在其它地方下载到基础镜像，然后按照自己的需要重置。 CentOS 的镜像下载网站是： http://cloud.centos.org/centos/ 。在其中选择自己想要下载的版本，列表中有一个 vagrant 目录，里面是专门为 vagrant 构建的镜像。选择其中的 .box 后缀的文件下载即可。这里可以使用下载工具，以较快的速度下载下来。 Ubuntu 的镜像下载网站是： http://cloud-images.ubuntu.com/ 。同样先选择想要的版本，然后选择针对 vagrant 的 .box 文件即可。如果这里官网的速度较慢，还可以从 清华大学的镜像站 下载。 接下来需要将下载后的 .box 文件添加到 vagrant 中。终端执行: 1vagrant box add .box文件的路径 --name 自定义镜像的名称 2.2 启动虚拟机方法一：终端启动虚拟机 vagrant up 网卡：Adapter 1: nat，第一块网卡，NAT 模式，这是固定的 端口转发：22 (guest) =&gt; 2222 (host) (adapter 1)，把虚机的 22 端口，映射到宿主机的 2222 端口上，这样就可以通过 127.0.0.1:2222 访问虚拟机了 SSH 用户名：vagrant，这里使用 private key 登录 ssh登录： 查看虚拟机状态： 方法二：在 VirtualBox 启动虚拟机 打开virtualbox： 3 Mac连接虚拟机3.1 设置Host-OnlyMac连接虚拟机的方法：设置一个Host-Only网络，为虚拟机增加一个Host-Only的网络适配器，实现主机与虚拟机之间的互通。 首先，启动虚拟机，创建一个Host-Only网络，点击新增，会创建 vboxnet0。 关闭虚拟机，设置虚拟机-&gt;网络-&gt;网卡2-&gt;启用网络连接-&gt;选择Host-Only，界面名称选择刚创建的vboxnet0，点OK，重启虚拟机。 mac查看 ifconfig 找到以太网适配器 VirtualBox Host-Only Network: 配置网络信息，打开”Vagrantfile”文件: config.vm.network&quot;private_network&quot;,ip:&quot;192.168.56.10&quot; 修改完成后，重启vagrant，ping一下检查宿主机和virtualBox之间的通信是否正常。 3.2 开启远程登录 4 遇到的问题https://blog.csdn.net/yimtcode/article/details/109702529 Multipass后面使用VirtualBox + Vagrant的过程中碰到很多问题，经常闪退卡死等等，推荐一款更好用的虚拟机软件吧：https://mp.weixin.qq.com/s/_0pZj4B-aHOtNlhnZnX0og 参考： https://zhuanlan.zhihu.com/p/259833884 https://www.jianshu.com/p/0cabd5072b86 https://blog.csdn.net/m0_37167788/article/details/78718245]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝自动收能量]]></title>
    <url>%2F2021%2F02%2F15%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E8%87%AA%E5%8A%A8%E6%94%B6%E8%83%BD%E9%87%8F%2F</url>
    <content type="text"><![CDATA[运行环境 macOS Big Sur 11.2 小米10的手机 准备工作安装uiautomator2安装方法： 1pip install --upgrade --pre uiautomator2 UiAutomator 是 Google 提供的用来做安卓自动化测试的一个 Java 库，可以获取屏幕上任意一个 APP 的任意一个控件属性，并对其进行任意操作。Uiautomator2 是在 Uiautomator 之上的 Python 的接口封装，简单来说 Uiautomator2 可以看到手机当前屏幕上有哪些控件，其坐标，并且还可以模拟点击。 开启开发者模式和USB调试手机接入电脑前首先需要开启开发者模式，并开启USB调试，USB安装 (以小米10为例：如下图)，这样才能保证uiautomator2有足够的权限操作你的手机。 第一次使用过uiautomator2后，它会在你手机上安装ATX这个应用，打开这个应用你就可以之后通过无线的方式操作你的手机了。 安装adbMac可以直接使用brew命令安装adb，需要先安装Homebrew： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装adb： 1brew install android-platform-tools 安装成功执行: 1adb devices 如下图所示即adb安装成功，并且手机和电脑连接成功。￼ 注：如果adb没有安装会报错 RuntimeError: No adb exe could be found. Install adb on your system。 具体实现代码实现（具体含义见注释）： 12345678910111213141516171819202122232425262728293031323334353637383940import uiautomator2 as u2import timeimport random# 连接手机d = u2.connect() # 第一次使用有线连接，手机需要插电脑上，并开启开发者模式和USB调试 # d = u2.connect(&quot;xxx.xxx.xxx.xxx&quot;) # 除了第一次以外，可以通过无线连接，电脑和手机需要在同一个局域网内# 打开支付宝d.app_start(&quot;com.eg.android.AlipayGphone&quot;) # Uiautomator2可以直接通过应用包名调起应用time.sleep(2) # 休眠2s等待支付宝完全启动# 打开蚂蚁森林d(text=&quot;蚂蚁森林&quot;).click() # Uiautomators2可以直接点击屏幕某个文字的位置，所以需要把蚂蚁森林放的支付宝首页，这样打开支付宝后就可以直接定位到蚂蚁森林的位置了time.sleep(5) # 休眠5s等待支付宝加载完 # 寻找能量def collectEnergy(cnt): print(&quot;开始第%d次偷能量！&quot; % cnt) # 扫描点击有能量出现的区域 for x in range(150,1000,150): for y in range(600,900,150): d.long_click(x + random.randint(10,20), y + random.randint(10,20), 0.1) time.sleep(0.01) if cnt != 1: d.click(536,1816)# 偷能量cnt = 1while True: collectEnergy(cnt) a = d.xpath(&quot;//*[@resource-id=&apos;J_tree_dialog_wrap&apos;]&quot;).get().bounds # 把所有能量可能出现的位置都扫一遍 d.click(1000, a[3]-80) # 点击找能量按钮跳到下一个人那继续偷 if d.xpath(&apos;//*[@text=&quot;返回我的森林&quot;]&apos;).click_exists(timeout=2.0): # 如果页面出现了“返回我的森林”说明已经没有能量可偷了，结束 break cnt += 1print(&quot;###结束###&quot;)# 退出支付宝d.app_stop(&quot;com.eg.android.AlipayGphone&quot;) 注：第一次电脑连接手机需要注释掉第七行，取消注释第六行，手机会自动安装ATX，后面就可以通过ATX上面显示的ip无线连接手机。手机上的ATX如图所示： 这个脚本有个问题就是，如果在收能量的时候弹出关注什么什么的弹窗，他就无法找到能量或者无法找到找能量按钮跳到下一个人那里继续偷，会报错或者死循环。再就是，最好可以每天定时自动运行脚本偷能量。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试框架 Mocha]]></title>
    <url>%2F2020%2F05%2F15%2Fmocha%2F</url>
    <content type="text"><![CDATA[https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880 http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html mocha[ˈmɒkə]诞生于2011年，是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。 mocha的特点主要有： 既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一； 可以自动运行所有测试，也可以只运行特定的测试； 可以支持before、after、beforeEach和afterEach来编写初始化代码。 使用Node.js提供的assert模块进行断言 describe是Jasmine的全局函数，用于创建一个测试套件，可以理解为一组测试用例的集合。describe函数接受两个参数（一个字符串和一个回调函数）。字符串是这个测试套件的名字或标题，通常描述被测试内容，用之前的比喻来说，describe就是一个故事，字符串就是这个故事的标题。回调函数是实现测试套件的代码块（称为describe块）。 it也是Jasmine的全局函数，用来在describe块中创建一个测试用例（spec），和describe一样，it接受两个参数（一个字符串一个回调函数），字符串参数是测试用例的名字或标题，回调函数是实现测试用例的代码块（称为it块）。 describe和it函数的字符串参数是很重要的。如果描述得当的话，你的测试可以将一个完整的测试场景以自然语言的形式表达出来，形成文档。describe和it都属于JavaScript函数，所以JavaScript的作用域规则也适用于此。用java中学过的全局变量与局部变量的概念来说，我们可以把describe类别为一个class，把it类比于里面的方法，在describe中声明的变量即全局变量，在它里面的所以的it中都可以使用。而it中声明的变量为局部变量，只在此it内部有效。 在Jasmine中有四个全局函数用于安装和拆卸，如下： beforeEach：在每一个测试用例（it块）执行之前都执行一遍beforeEach函数 afterEach：在每一个测试用例（it块）执行之后都执行一遍afterEach 函数 beforeAll：在测试套件（describe块）中所有测试用例执行之前执行一遍beforeAll函数 afterAll：在测试套件（describe块）中所有测试用例执行之后执行一遍afterAll函数 Jasmine中describe块代码与it块代码及拆装与卸载的执行顺序： 首先执行的是：其他，不管是外部describe中的其他还是内部describe块中的其他，总之先将其他全部执行，顺序是从上往下。 第二步：找出it块，以it为中心，从外往内找beforeAll,beforeEach，先执行beforeAll，再执行beforeEach，且一个describe中的beforeAll只执行一遍，只有第一个it块执行前会先执行beforeAll,而其他的it块不会有该步骤；而beforeEach则是每个it块执行前都会先执行beforeEach。 第三步：执行it块中代码； 第四步：以it为中心，从内往外执行afterEach和afterAll，先执行afterEach再执行afterAll，执行顺序与beforeAll及beforeEach相反，这里需要注意的是，beforeAll只在该describe块中的最后一个it执行后才会执行，其他it块不会。 Jasmine的断言是期望值与实际值比较，一致则通过，不一致则失败。那么我们比较的类型有多少呢？ 如果两个值是数值，我们可以想到：等于，不等于，大于，小于，大于等于，小于等于，约等于等 如果两个是布尔值，我们可以想到：值为ture，值为false； 如果两个是对象，我们可以想到：对象相等，被定义，未被定义，是否为null 还有一些其他的：根据字符串、正则表达式筛选是否符合规则，是否抛出异常，报错信息是否一致等等，我们还可以自定义匹配器。 同步：如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 异步:如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mocha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac配置]]></title>
    <url>%2F2019%2F12%2F27%2FMac%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装Homebrew链接：https://brew.sh/index_zh-cn.html 安装命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程中出现的问题：报错curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation 解决方法：https://blog.csdn.net/zbc415766331/article/details/104128351/ 下载文件brew_install.rb，控制台运行ruby brew_install.rb命令。此文件下载地址： https://pan.baidu.com/s/1rVh8bY73NLc77cQYN_2HoQ 密码：n3si 后来又有一次安装homebrew时发现运行这个文件时报了其他错误，又参考了另一个解决方法 https://www.jianshu.com/p/c8d998903a6a 。 安装wget安装wget： 1brew install wget wget访问https出现问题wget https://www.apache.org/ ——出现unsupported scheme提示，这是必然的，因为这是个安全链接。 加个选项试试，不检查证书，wget –no-check-certificate https://www.apache.org/ ，提示没有这个选项 wget: unrecognized option –no-check-certificate 解决方法：参考：https://www.jianshu.com/p/94bb06811a26 查找wget: 1find /usr/ -name &quot;wget&quot; 输出： 123/usr//local/bin/wget/usr//local/Cellar/wget/usr//local/Cellar/wget/1.19.5/bin/wget 删除系统默认版本： 1sudo rm -f /usr/local/bin/wget 解决: 1sudo cp /usr/local/Cellar/wget/1.19.5/bin/wget /usr/local/bin/ 安装anaconda3下载地址：https://www.anaconda.com/distribution/#macos 下载哪一个都可以，一个是窗口安装，一个是命令行安装，以命令行为主： cd到下载目录下，执行如下代码： 1bash Anaconda3-5.3.0-MacOSX-x86_64.sh 添加环境变量： 1sudo vim ~/.bash_profile 在 .bash_profile 文件中添加下面文本: 1export PATH=&quot;/Users/xxx/anaconda3/bin:$PATH&quot; 刷新生效source: 1source ~/.bash_profile 卸载Anaconda123rm -rf ~/anaconda3vim ~/.bash_profilerm -rf ~/.condarc ~/.conda ~/.continuum 手动删除文件夹，然后再去把配置文件里面对应的环境变量删了。 Fliqlo翻页时钟参考：https://zhuanlan.zhihu.com/p/105069716?utm_source=wechat_session 安装iTerm2不得不说mac自带的终端是真的丑，来配置下iTerm2吧 参考：https://zhuanlan.zhihu.com/p/37195261 安装Oh my zsh过程中出现的问题：raw.githubusercontent.com (raw.githubusercontent.com)|::|:443… 失败：拒绝连接 解决方法：https://blog.csdn.net/wowbing2/article/details/105797442/ 进入网站： https://site.ip138.com/raw.Githubusercontent.com/ 输入 raw.githubusercontent.com ，查询其相关的IP地址 终端输入 sudo vi /etc/hosts 添加 151.101.xx.133 raw.githubusercontent.com 保存，退出 :wq 在浏览器运行命令行https://mp.weixin.qq.com/s/fOTFQRetykkcpoWCW6A8xA]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep Learning时代最好用的云GPU——Google Colab]]></title>
    <url>%2F2019%2F12%2F22%2FDeep-Learning%E6%97%B6%E4%BB%A3%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E4%BA%91GPU%E2%80%94%E2%80%94Google-Colab%2F</url>
    <content type="text"><![CDATA[Colab是Google基于Google Drive存储的对外免费开放的云服务器，主要有CPU,GPU,TPU三种可选硬件加速方案。最近，Colab 将 以前的 K80 替换为 Tesla T4，新一代图灵架构、16GB 显存，重点是免费 GPU！免费！免费！。因此强烈建议大家赶紧薅谷歌的羊毛，获取强大的免费算力。 原文链接：https://blog.csdn.net/jinyuan7708/article/details/89948938 Googole Colab官网链接：https://colab.research.google.com/notebooks/welcome.ipynb#recent=true 使用Google Colab运行或导入.py文件 12from google.colab import drivedrive.mount(&apos;/content/drive/&apos;) 单击出现的链接，复制验证码并将其粘贴到文本框中。完成授权过程后，就可以了。 通过以下方式与Google联系 1!ls &quot;/content/drive/My Drive/&quot; 在Colab中cd命令是无效的，切换工作目录使用chdir函数 12import osos.chdir(&quot;drive&quot;) 回到上级目录 12import osos.chdir(&quot;../&quot;) 如果要将.csv文件从url下载到“Colab tutorial”文件夹，只需运行 1! wget https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/datasets/Titanic.csv -P&quot;/content/drive/My Drive/Colab tutorial&quot; 查看您当前是否在Colab中使用GPU 12import tensorflow as tftf.test.gpu_device_name() 查看使用的是哪种GPU 12from tensorflow.python.client import device_libdevice_lib.list_local_devices() RAM怎么样？ 1! cat /proc/meminfo 那CPU怎么样？ 1! cat /proc/cpuinfo 查看tensorflow版本号 12import tensorflow as tftf.__version__ 安装tensorflow 1.8 1!pip install tensorflow==1.8.0rc]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>colab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「日常实习」大四百度测试开发实习]]></title>
    <url>%2F2019%2F11%2F15%2F%E7%99%BE%E5%BA%A6%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一面主管面一面大约20多分钟. 1、自我介绍 2、python （1）字典： （2）字典怎么获取所有键： （3）列表和元组的区别： 列表可以看成是动态数组,它们是可变的并且可以重新设定长度 元组可以看成是静态的数组,它们是不可变的,并且长度也是一旦创建就无法改变 从设计上来说: 列表是用来保存多个相互独立对象的数据集合 元组设计的初衷就是为了描述一个不会改变的事物的多个属性 （4）list排序：list.sort(cmp=None, key=None, reverse=False) （5）浅拷贝与深拷贝的区别： Python3中，有6个标准的数据类型，他们又分为可变和不可变： 不可变数据（3个）：Number（数字）String（字符串）Tuple（元组）。 可变数据（3个）：List（列表）Dictionary（字典）Set（集合） 浅拷贝 对于不可变类型Number String Tuple,浅复制仅仅是地址指向，不会开辟新空间。 对于可变类型 List、Dictionary、Set，浅复制会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝 浅拷贝后，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象的；改变原始对象中为不可变类型的元素的值，只有原始类型受影响。 （操作拷贝对象对原始对象的也是同理） 深拷贝 浅拷贝除了顶层拷贝，还对子元素也进行了拷贝（本质上递归浅拷贝） 经过深拷贝后，原始对象和拷贝对象所有的子元素地址都是独立的了 可以用分片表达式进行深拷贝 字典的copy方法可以拷贝一个字典 3、你学过数据结构吗？说说二分查找 4、说一下面向对象的特征？ 封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 多态：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 5、了解微信小程序吗？ 6、了解测试吗？给你一个页面怎么进行测试？比如微信的登录界面。 其他就是问了项目里面的一些东西，比如数据库是怎么设计的等等。 二面主管面二面也是先自我介绍，接下来就是说到一个点面试官比较感兴趣，就一直深入提问。 了解开发测试吗？ 了解小程序吗？ 除了微信小程序其他的呢，了解百度的小程序吗？ 说一下在做项目的过程中遇到的一个问题，怎么解决的，具体的说一下细节。等等等。 最后问：你有什么问题问我吗？ 三面经理面跟二面类似，先自我介绍，我是自己搭了这个博客，把链接附到简历上，整个面试三十多分钟面试官一直在问关于这个博客的问题。 博客搭好后怎么测试的？ 说一下在做项目的过程中遇到的一个问题，怎么解决的，具体的说一下细节。 你看过哪些关于技术方面的书？ 最后问：你有什么问题问我吗？ 2020.8 更： 把实习的经历做成了一个视频： https://www.bilibili.com/video/BV1oa4y1L7aJ 欢迎三连哦！]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
      <tags>
        <tag>大四实习面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客更换成自己的域名]]></title>
    <url>%2F2019%2F11%2F05%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在腾讯云花了五毛钱买了一个一年的域名，决定把我的博客更换成自己的域名！ 打开管理控制台解析 打开cmd ping 一下你的（例如：xxx.github.io） 就可以得到 这个就是记录值 如下图所示填入解析页面 在Hexo目录下的source中建一个CNAME命名的文本文件 绑定域名进入github 项目中，点击setting，进入setting页面后，往下找，改成你购买的域名 这样就能通过访问我们购买的域名去访问博客 最后要说的是：博客源码 ，欢迎 star !]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于GitHub+hexo搭建的个人博客备份]]></title>
    <url>%2F2019%2F10%2F30%2F%E4%BD%BF%E7%94%A8hexo-GitHub%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[担心博客.md文件放在本地容易丢失，就新建了一个分支来备份。 第一次备份 在xxx.github.io文件夹, 右键选择Git Bash 进入命令行，进入项目所在目录，输入 touch .gitignore ，生成“.gitignore”文件。 在本地文件根目录中初始化 : git init 创建分支hexo ： git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库 1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支 : git push origin hexo 日常的改动流程 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo） 然后才执行hexo g -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 在另一台电脑上使用 首先要克隆下这个项目 : git clone xxx 进入博客目录，切换到博客文件分支 ：git checkout -b hexo origin/hexo 安装hexo ： npm install hexo –save （不需要hexo init这条指令）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器Ubuntu]]></title>
    <url>%2F2019%2F10%2F29%2F%E4%BD%BF%E7%94%A8WinSCP%E7%BB%99%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E7%B3%BB%E7%BB%9F%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本地Windows环境上传文件到阿里云服务器（Ubuntu）WinSCP下载与安装下载链接：https://winscp.net/eng/download.php安装根据提示一步一步来即可 远程连接此处输入主机名和密码 用户名即可（均在阿里云服务器上的配置页面可见） 链接成功后如下图所示： 本地ubuntu系统上传文件到阿里云服务器（Ubuntu）把本地/home/xxx/xxx/xx.py文件传入到/home/download文件夹下，使用如下命令： 1scp /home/xxx/xxx/xx.py root@39.xxx.xx.xx:/home/download 然后输入服务器密码即可 阿里云ubantu下载anaconda3并配置jupyter notebook参考：https://www.jianshu.com/p/fff4a61dee7a 配置云服务器的安全组设置过程：云服务器管理控制台》云服务器ECS》网络和安全》安全组》配置规则》添加安全组规则授权对象这个我是填 0.0.0.0/0 。表示这个端口开放给所有ip 安装anaconda312345678910111213141516171819202122232425262728下载anaconda3清华镜像：sudo wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.shsudo bash Anaconda3-5.0.1-Linux-x86_64.sh激活环境变量:source /etc/environment 添加Anaconda的TUNA镜像:conda config --add channels &apos;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&apos;设置搜索时显示通道地址：conda config --set show_channel_urls yes创建jupyter notebook运行环境，可以方便管理各类库conda create -n jupyter_notebook python=3激活环境source activate jupyter_notebook如果要退出环境的话，执行：source deactivate # 暂时不执行安装jupyter notebook (这个过程是接着激活环境后的)conda install jupyter notebook测试jupyter notebook --ip=127.0.0.1终端输出正常即可 配置jupyter notebook远程访问1234567891011121314151617181920212223242526272829303132jupyter notebook --generate-config生成文件后，文件在该目录下Writing default config to: /home/xx/.jupyter/jupyter_notebook_config.py打开jupyter_notebook_config.py文件（可以在winscp里面编辑这个文件）vim /home/xx/.jupyter/jupyter_notebook_config.py设置可以访问服务器的ip（在最后加上一行）c.NotebookApp.ip = &apos;*&apos;打开ipython：ipython调用passwd()函数生成密匙，把密匙复制下来，后面会有用：In [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[2]: &apos;sha1:8361f5f08937:081cdf40730cb5548e2c213ddd36813a5313192f&apos;设置不在服务器端自动打开浏览器（继续在后面添加）：c.NotebookApp.password = &apos;sha1:8361f5f08937:081cdf40730cb5548e2c213ddd36813a5313192f&apos;c.NotebookApp.open_browser = False启动一下jupyter notebook是不是可以访问：jupyter notebook然后在自己电脑浏览器网址里输入：云服务器公网ip：8888大功告成！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apk反编译工具的使用]]></title>
    <url>%2F2019%2F10%2F14%2FAndrowarn%2F</url>
    <content type="text"><![CDATA[Android tools github地址：https://github.com/maoqyhz/DroidCC/blob/master/tools.md下面是几个Android恶意代码检测用到的工具，总结一下下载方法和使用方法，安装环境为ubantu18.04。 apktool：是apk格式文件与smali文件的转换dex2jar：是dex格式文件与jar文件的转换smali/baksmali：是dex格式文件与smali文件的转换 Androguardandroguard主要用来进行静态分析，其默认采用ded作为反编译的软件，同时提供了很多模块供分析人员使用。 学习链接： github地址: https://github.com/androguard/androguard 项目主页: https://code.google.com/archive/p/androguard/ 使用文档: https://androguard.readthedocs.io/en/latest/index.html 附一个中文版Androguard使用说明： https://www.jianshu.com/p/079e40800ef4 安装: 1pip install -U androguard 使用： 命令行输入:androguard analyze 或者用jupyter notebook，当然其他IDE也行，下载好androguard后他就相当于python的一个包，可以直接导入：import androguard 123from androguard.misc import AnalyzeAPKa, d, dx = AnalyzeAPK(&quot;sample.apk&quot;)print(a,d,dx) 关于Androguard的项目： AndroPyTool AndrowarnAndrowarn是一款专为Android端应用程序设计的安全分析工具，主要功能是检测并提醒用户Android应用程序中潜在的恶意行为。在androguard库的帮助下，Androwarn可以通过对目标应用程序的Dalvik字节码和Smali代码进行静态分析，来判断目标应用程序中潜在的恶意行为。分析完成之后，工具会自动生成分析报告，报告中的技术细节划分，取决于用户的设置参数。 学习链接： github链接: https://github.com/maaaaz/androwarn/ 附一个中文版教程链接: https://www.freebuf.com/sectool/199407.html 安装： 12pip install androwarn# Or git clone that repository and ：pip install -r requirements.txt 使用： 1python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3 把github仓库clone到本地，cd 该文件夹，打开终端，把上面命令行的my_application_to_be_analyzed.apk换成你自己要分析的apk文件的名字，就会在该文件夹生成一个html分析文件。如下图所示： ApktoolAPKTool是GOOGLE提供的APK编译工具，需要JAVA运行环境，是逆向分析工具. 学习链接： 博客教程: https://ibotpeaches.github.io/Apktool/ github地址：https://github.com/iBotPeaches/Apktool github地址2：https://github.com/iBotPeaches/Apktool/tree/gh-pages 安装： 下载 Linux wrapper script 链接 (右击，保存为 apktool) 下载 apktool-2 链接 (保存为apktool.jar) 移动文件 (apktool.jar &amp; apktool) 到 /usr/local/bin（sudo cp -i aapt apktool apktool.jar /usr/local/bin/ 基本上到这一步就结束了） 保证文件可执行 (chmod +x) 在命令行运行apktool 使用： decode：该命令用于进行反编译apk文件apktool d file.apk dirfile.apk：代表了要反编译的apk文件的路径，最好写绝对路径dir：代表了反编译后的文件的存储位置 build：该命令用于编译修改好的文件apktool b dir 这里的dir就是刚才你反编译时输入的dir DroidboxDroidBox是用来动态分析Android应用行为的工具。 学习链接： 官网链接：https://code.google.com/archive/p/droidbox/ github地址：https://github.com/pjlantz/droidbox 安装：（参考：https://blog.csdn.net/u012195899/article/details/52814013） Oracle JDK（在本博客《ubantu配置》一文中写了jdk安装教程） 安装sdk：linux 服务器下载：wget http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz将压缩包解压到/home/android/sdk 目录下修改环境变量：export PATH=/home/name/Android/Sdk/android-sdk-linux/tools:$PATHexport PATH=/home/name/Android/Sdk/android-sdk-linux/platform-tools:$PATHsource ~/.bashrc sdk、avd管理/home/dccun/Android/Sdk/android-sdk-linux/tools目录下：终端输入android即可进入sdk管理，可下载avd安装完成之后，大家可以在命令行输入一下命令来查看当前的安装版本：android list targets下载完之后create虚拟机点击OK创建完毕。这个时候大家可以先运行一下avd是否能够正常开机。我的虚拟机名称是droid，因此命令如下：emulator -avd droid如果成功运行，那么恭喜，你的sdk部分已经配置完成！如果想要删除某个虚拟机，使用的命令为:android delete avd -n avd_name。android list target #查看可获取的安卓虚拟机android list avd #查看已创建的安卓虚拟机 下载最新版的DroidBoxhttps://github.com/pjlantz/droidbox/releases ，这里我下载的时候最新版为：DroidBox411RC.tar.gz进入droidbox目录下：启动虚拟机：./startemu.sh droid开始分析：./droidbox.sh 1.apk（apk使用绝对路径）可以设置分析时间：./droidbox.sh 1.apk 10 (10表示10s) 在虚拟机下载apk把apk放到/Android/Sdk/android-sdk-linux/platform-tools目录下，在这个目录下进入终端，输入adb install sample.apk即可，实践效果如下图所示： 出现的问题及解决方法： Linux系统(Ubuntu)下AndroidStudio创建AVD虚拟器出现“/dev/kvm is missing”参考：https://blog.csdn.net/lpcrazyboy/article/details/80270816(1)进入BIOS里，把Virtualization Technology(VT)的状态由Disable改为Enable。（这个在cpu模块里找）(2)打开终端，输入：sudo apt-get install qemu-kvm(3)安装完成后，输入：sudo kvm-ok ubuntu18.04系统下androidstudio启动模拟器发生错误: /dev/kvm device:permission denied参考：https://blog.csdn.net/blackei/article/details/84559180在终端输入：sudo chown username -R /dev/kvm将username替换成自己电脑当前登录的用户名称即可。如当前电脑登录的是android，那么在终端输入的则为：sudo chown android -R /dev/kvm JD-GUI学习链接 https://github.com/java-decompiler/jd-gui http://java-decompiler.github.io/ dex2jardex2jar是将apk中的java源码编译生成的java字节码文件反编译成java源码。 学习链接 https://github.com/pxb1988/dex2jar 下载：下载链接 使用： 1sh d2j-dex2jar.sh -f ~/path/to/apk_to_decompile.apk 运行结束后会在d2j-dex2jar.sh所在文件夹下生成apk_to_decompile-dex2jar.jar文件 smali/baksmalismali是将Android字节码用可阅读的字符串形式表现出来的一种语言,可以称之为Android字节码的反汇编语言。 学习链接 https://github.com/JesusFreke/smali 逆向之Smali入门学习 下载：下载链接]]></content>
      <categories>
        <category>Android恶意代码检测</category>
      </categories>
      <tags>
        <tag>android-tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu双系统配置记录]]></title>
    <url>%2F2019%2F09%2F30%2Fubantu%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[今天装了Windows+ubuntu18.04双系统，记录一下安装完ubuntu之后做的事情，和使用ubuntu的过程中遇到的问题、解决方法、小技巧。 ubuntu是基于debian开发的，centos是基于redhat开发的，所以ubuntu可以使用deb结尾的包，而centos使用rpm结尾的包。 显示文件夹中隐藏的文件：ctrl+H。 查看Ubuntu显卡的型号： 1lspci|grep VGA 查看CPU 1lscpu usr内文件夹的删除复制移动 123456一：复制移动sudo cp 要复制的文件 /usr/local/bin（目的文件夹）sudo mv 要移动的文件 /usr/local/bin（目的文件夹）二：删除sudo su #进入root下rm -rf 要删除的文件 linux对文件赋权限的命令chmod参考：https://www.cnblogs.com/insane-Mr-Li/p/10716293.html使用方式 : chmod [-cfvR] [–help] [–version] mode file… 卸载软件参考：https://blog.csdn.net/luckydog612/article/details/80877179输入dpkg –list终端输出电脑上安装的所有软件在终端上输入命令sudo apt-get –purge remove 包名（–purge是可选项，写上这个属性是将软件及其配置文件一并删除，如不需要删除配置文件，可执行sudo apt-get remove 包名） Ubuntu配置环境变量的两种常用方法（.bashrc和/etc/profile）参考：https://blog.csdn.net/yiminghd2861/article/details/98854882 双系统安装过程记录参考: https://blog.csdn.net/weixin_43538911/article/details/99647086 卸载ubuntu参考：https://blog.csdn.net/lele_god/article/details/109046860 ubuntu下可删除哪些文件来释放系统空间？参考：https://zhidao.baidu.com/question/166531881.html 安装好Ubuntu18.04之后要做的事大全参考: https://blog.csdn.net/haeasringnar/article/details/81809040要安装搜狗拼音、git可以按照这个里面的教程，下面补充几个更好用的按照教程 安装搜狗拼音如果按照上面一条安装后，因为个人失误导致搜狗拼音不能用，可以参考下面教程：https://blog.csdn.net/qq_33159059/article/details/85019467 12345678910111213# 先卸载掉fcitx，及其所有相关的软件sudo apt -y remove *fcitx*# 然后来个彻底清除sudo apt autoremove# 安装了下面的这部分，搜狗输入法就可以使用了，不过候选区没有背景，是透明的sudo apt -y install fcitx fcitx-bin fcitx-table fcitx-table-all# 安装fcitx可视化的配置界面sudo apt -y install fcitx-config-gtk# 就安装gtk，不要安装gtk2。因为gtk2的配置界面没有gtk的强大，而且同时安装，也只有gtk的生效sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb进入“语言支持”界面，进行输入法框架的配置：![upload successful](/images/pasted-10.png)最后重启，确保设置都已生效 安装 Anaconda3参考: https://blog.csdn.net/qq_15192373/article/details/81091098 1234567在清华大学开源软件镜像站下载：https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/bash Anaconda3-5.2.0-Linux-x86_64.sh若在终端输入 python，仍然会显示Ubuntu自带的python版本，我们执行：sudo gedit ~/.bashrc在最后一行添加：export PATH=&quot;/home/xxx/anaconda3/bin:$PATH&quot; 问题：pip命令报错Traceback (most recent call last): File “/usr/bin/pip”解决：https://blog.csdn.net/lyll616/article/details/85090132 12345打开终端，在终端中输入 ： sudo gedit /usr/bin/pip插入或者修改为：from pip import __main__ //修改if __name__ == &apos;__main__&apos;: sys.exit(__main__._main())//修改 安装Mac主题https://zhuanlan.zhihu.com/p/71588449尝试了一下效果不错 安装MySQL8.0参考:https://www.cnblogs.com/luoli-/p/9249769.htmlubuntu18.04首次登录mysql未设置密码或忘记密码解决方法:https://blog.csdn.net/qq_38737992/article/details/81090373 1234567下载deb包：https://dev.mysql.com/downloads/repo/apt/sudo dpkg -i mysql-apt-config_0.8.10-1_all.debsudo apt updatesudo apt install mysql-server密码加密方式选择5.x查看mysql是否安装成功：mysql -u root -p查看mysql字符集，mysql8字符集默认为utf-8：show variables like &apos;%char%&apos;; 安装mendeley参考:https://www.mendeley.com/guides/download-mendeley-desktop/ubuntu/instructions 12在上面链接中下载deb包sudo dpkg -i &lt;path-to-downloaded-package&gt; 在使用过程中出现不能输入中文的现象，解决方法：https://blog.csdn.net/weixin_40100431/article/details/82633423 12345首先在终端中定位一个文件的位置locate libfcitxplatforminputcontextplugin.so然后将上述文献拷贝到mendeley的安装路径当中sudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /opt/mendeleydesktop/plugins/qt/plugins/platforminputcontexts/关闭mendeley重新启动即可。 安装配置JAVA环境参考:https://blog.csdn.net/weixx3/article/details/80296779 1234567891011121314去oracle官网下载：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html解压后，将文件从下载目录挪到/usr/local下sudo mv jdk1.8.0_171 /usr/local/jdk1.8修改全局配置文件，作用于所有用户：vim /etc/profileexport JAVA_HOME=/usr/local/jdk1.8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH修改完后保存并退出，按下Esc后输入:q!即可使修改的配置立刻生效 ： source /etc/profile 检查是否安装成功：java -version 安装wps安装按照上面《安装好Ubuntu18.04之后要做的事大全》一文，字体缺失按照下面教程：WPS for Linux（ubuntu）字体配置(字体缺失解决办法)：https://www.cnblogs.com/liangml/p/5969404.html 1234567891011在官网下载wps：https://www.wps.cn/product/wpslinux/安装wps：sudo dpkg -i wps*.deb 安装wps下载缺失字体：国内下载地址：https://pan.baidu.com/s/1eS6xIzo下载完成后，解压并进入目录中，继续执行：sudo cp * /usr/share/fontssudo mkfontscalesudo mkfontdir运行fc-cache命令更新字体缓存：sudo fc-cache重启wps即可，字体缺失的提示不再出现。 安装node、npm、hexo参考：https://www.cnblogs.com/guanine/p/9392411.htmlhttps://blog.csdn.net/Iversonx/article/details/82807598 12345678键入以下内容刷新本地包索引：sudo apt update从存储库安装Node.js：sudo apt install nodejs需要额外安装npm，你可以通过输入以下命令来完成sudo apt install npm 安装hexosudo npm install --unsafe-perm --verbose -g hexo 安装网易云音乐参考： https://blog.csdn.net/weixin_43693233/article/details/90685359第一次下载网易云音乐，点击图标打不开，只能用sudo进入，很麻烦，百度也看到好多人都是这种问题，上面这个教程下载的网易云是点击图标可以直接进入的，推荐！ 安装Android studio参考：https://blog.csdn.net/Sacredness/article/details/86514460我并没有安装SDK，百度了一下有的博客说android studio 可以默认帮你安装android-sdk。 下载地址：https://developer.android.google.cn/studio/#downloads将压缩包解压到要安装的位置在软件的bin目录下打开命令行，执行命令bash studio.sh.（如果你需要root权限，执行sudo bash studio.sh）创建桌面图标：至于怎么新建一个项目，参考：https://blog.csdn.net/Sacredness/article/details/82929768 安装pycharm同上 安装idea参考：https://blog.csdn.net/lishundi/article/details/82762532 12345下载地址: https://www.jetbrains.com/idea/download/#section=linux 解压到/opt下：sudo tar -zxvf ideaIC-2018.2.3-no-jdk.tar.gz -C /opt进入到opt位置：cd /opt/进入到IDEA文件夹下的bin目录：cd /opt/idea-IC-182.4323.46/bin启动 IDEA：./idea.sh 截图工具flameshot参考：https://www.jianshu.com/p/e1678c1d175d 1sudo apt-get install flameshot 设置&gt;设备&gt;键盘，设置一个自定义快捷键（拉到最下面）命令填写：flameshot gui 截完图后保存Ctrl+S，复制到剪贴板 Ctrl+C]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019电子竞赛准备和比赛过程记录]]></title>
    <url>%2F2019%2F08%2F07%2F2019%E7%94%B5%E5%AD%90%E7%AB%9E%E8%B5%9B%E5%9B%BD%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[比赛时间：2019.8.7-2019.8.10 7月31日（没有时间仔细写笔记，只做简单记录，仅供自己比赛使用） 复习PID算法五月份的时候练习2017年国赛滚球系统已经了解过PID算法，但是并不熟练，比赛前还是有必要再进一步熟悉PID算法的。滚球经验总结 摄像头openmv17年国赛控制题滚球系统用到了摄像头的图像处理，老师预测19年还会用到图像处理，因此我们选择了openmv。跟ov系列摄像头比起来，openmv实在是太好用了，不用再拘泥于C，可以使用python。上面滚球经验总结里面也有写openmv跟stm32f407战舰版通信方法。openmv主要就是在官网学习的。 接线方式：openmv——407核心板P4————RX（PA10_USART1）P5————TX（PA9_USART1）GND———GND MPU6050六轴传感器MPU6050 采用 IIC 与 STM32F4 通信。姿态数据，也就是欧拉角——航向角（yaw）、横滚角（roll）、俯仰角（pitch）。MPU6050 自带了数字运动处理器，即 DMP。检测轴及方向： MPU6050 与探索者 STM32F4 开发板的连接： 8月1日今天台风登陆小岛~一直到上午十点多才来电，中午出了器材清单，开始猜题。 8月2日今天一天就是看网上各种猜题，淘宝找做控制类的器材，报给学校一份，自己买了一份备用（主要因为学校买的各种不靠谱）。 8月3日SD卡的使用openmv——SD卡先插SD卡再上电SD卡的文件系统会自动取代内置的Flash文件系统openmv使用SD卡的情况： 代码行数太多 存储图片 录制视频 stm32——SD卡只运行了stm32自带的例程，并不懂SD卡怎么用。。。 通信通信很重要，当初做滚球，openmv和stm32通信传输小球坐标时费了很大劲，通信还是要好好看看。 蓝牙模块HC-05 参考博客主要想实现的功能是手机蓝牙控制STM32——手机通过蓝牙传输到HC-05上，再通过串口通信和STM32通信。我们组在网上买了一个组装好的小车，手机APP通过蓝牙HC06控制，蓝牙名称BT04，密码1234。测试APP：蓝牙模块通过stlink连接电脑，用串口调试助手观察按下APP的按键时接收的信息。蓝牙串口APP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;stm32f10x.h&quot; void My_USART1_Init(void) &#123; GPIO_InitTypeDef GPIO_InitStrue; USART_InitTypeDef USART_InitStrue; NVIC_InitTypeDef NVIC_InitStrue; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//GPIO端口使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//串口端口使能 GPIO_InitStrue.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_InitStrue.GPIO_Pin=GPIO_Pin_9; GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStrue); GPIO_InitStrue.GPIO_Mode=GPIO_Mode_IN_FLOATING; GPIO_InitStrue.GPIO_Pin=GPIO_Pin_10; GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStrue); USART_InitStrue.USART_BaudRate=115200; USART_InitStrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None; USART_InitStrue.USART_Mode=USART_Mode_Tx|USART_Mode_Rx; USART_InitStrue.USART_Parity=USART_Parity_No; USART_InitStrue.USART_StopBits=USART_StopBits_1; USART_InitStrue.USART_WordLength=USART_WordLength_8b; USART_Init(USART1,&amp;USART_InitStrue); USART_Cmd(USART1,ENABLE);//使能串口1 USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);//开启接收中断 NVIC_InitStrue.NVIC_IRQChannel=USART1_IRQn; NVIC_InitStrue.NVIC_IRQChannelCmd=ENABLE; NVIC_InitStrue.NVIC_IRQChannelPreemptionPriority=1; NVIC_InitStrue.NVIC_IRQChannelSubPriority=1; NVIC_Init(&amp;NVIC_InitStrue); &#125; void USART1_IRQHandler(void) &#123; u8 res; if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) &#123; res= USART_ReceiveData(USART1); USART_SendData(USART1,res); &#125; &#125; int main(void) &#123; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); My_USART1_Init(); while(1); &#125; WiFi模块ESP8266 VCC连接正极(有些是3.3V,有些是5V)GND连接负极RXD:数据的接收端 (连接单片机或者USB转TTL模块的TXD)TXD:数据的发送端 (连接单片机或者USB转TTL模块的RXD) 参考博客 NRF24L01无线模块 NRF24L01是SPI 通信接口。 主要想实现的功能是——两个开发板通信，如果做图像处理，有时候一块开发板不够用，就需要两块开发板。开发板上 NRF24L01 模块接口和 STM32F4的连接： 8月4日学校负责老师突然让学生自己买器材，离比赛只剩两天半时间，服气。 云台在网上买了几个二维云台，用2个舵机控制。 比赛A题无线充电小车是去年省赛的题目，没想到会连续出两年，完全没准备，放弃。B题是巡线四旋翼，难，放弃。F题纸张计数，学校仪器设备不够，放弃。最后选了H题，电磁炮，正好用到了之前做滚球时的舵机和openmv。由于H题只要能成功发射电磁炮就能得十分，所以选这个人的题特别特别多，测评结束后我们学校获奖的六个组其中五个组是做电磁炮。只捡几个点写一下吧，毕竟最后只拿了省二~结果不尽人意，大神太多 电磁炮的炮管放在二维云台上控制电磁炮水平垂直运动，通过控制继电器高低电平控制充电时间，通过控制舵机旋转控制炮管角度，进而控制炮弹发射距离和方向。 按键模块使用的是手机APP，通过蓝牙模块HC-05向开发板（stm32F407核心板）传输发射距离和角度。 发挥部分的自动寻靶和测距用的是openmv，这些都能在openmv官网找到代码，openmv找到靶子并且测得距离后通过串口发送给开发板，继而控制舵机，然后发射炮弹。]]></content>
      <categories>
        <category>电子竞赛</category>
      </categories>
      <tags>
        <tag>电子竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令入门学习笔记]]></title>
    <url>%2F2019%2F05%2F30%2FLinux%2F</url>
    <content type="text"><![CDATA[友链: 看完这篇Linux基本的操作就会了:https://zhuanlan.zhihu.com/p/36801617 搞定 Linux 这一篇就够了：https://mp.weixin.qq.com/s/XWKgzgVDk6lhhzRnYEmEJw Linux命令概览 一些命令： df命令用来查看系统中磁盘的使用量，用来查看磁盘是否已经到达上限。参数h可以以友好的方式进行展示。 Linux系统的组成： linux内核（linus 团队管理） shell：系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器) 文件系统：ext3、ext4等,windows 有 fat32 、ntfs 第三方应用软件 文件系统结构 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 通配符 *：匹配任何字符和任何数目的字符 ?：匹配单一数目的任何字符 [ ]：匹配[ ]之内的任意一个字符 [! ]：匹配除了[! ]之外的任意一个字符，!表示非的意思 文件的类型 普通文件- 目录d 符号链接l 硬链接：与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块 软链接：保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径(简单地理解为 Windows 中常见的快捷方式)。 字符设备文件 c 块设备文件b 套接字s 命名管道p 常用的文件、目录操作命令 pwd命令查看用户的当前目录 cd 命令来切换目录 .表示当前目录 .. 表示当前目录的上一级目录（父目录） -表示用 cd 命令切换目录前所在的目录 ~ 表示用户主目录的绝对路径名 ls：显示文件或目录信息 mkdir：当前目录下创建一个空目录 rmdir：要求目录为空 touch：生成一个空文件或更改文件的时间(可以改变文件的三种时间，分别是： access time 、 modify time 、 change time) cp：复制文件或目录 mv：移动文件或目录、文件或目录改名 rm：删除文件或目录 ln：建立链接文件 find：查找文件 file/stat：查看文件类型或文件属性信息 cat：查看文本文件内容 more：可以分页看 less：不仅可以分页，还可以方便地搜索，回翻等操作 tail -10： 查看文件的尾部的10行 head -20：查看文件的头部20行 别名alias echo：把内容重定向到指定的文件中 ，有则打开，无则创建 管道命令 | ：将前面的结果给后面的命令，例如：ls -la | wc，将ls的结果加油wc命令来统计字数 重定向 &gt; 是覆盖模式，&gt;&gt; 是追加模式，例如：echo “Java3y,zhen de hen xi huan ni” &gt; qingshu.txt把左边的输出放到右边的文件里去 文件打包和压缩命令 压缩的方式也是有好几种，我们常用的有下面这三种： gzip bzip2 tar 常用的压缩的命令就有： gzip filename bzip2 filename tar -czvf filename 常用的解压命令有： gzip -d filename.gz bzip2 -d filename.bz2 tar -xzvf filename.tar.gz 正则表达式grep(global search regular expression)是一个强大的文本搜索工具。grep 使用正则表达式搜索文本，并把匹配的行打印出来。格式：grep [options] PATTERN [FILE…] PATTERN 是查找条件：可以是普通字符串、可以是正则表达式，通常用单引号将RE括起来。 FILE 是要查找的文件，可以是用空格间隔的多个文件，也可是使用Shell的通配符在多个文件中查找PATTERN，省略时表示在标准输入中查找。 grep命令不会对输入文件进行任何修改或影响，可以使用输出重定向将结果存为文件 例子： 在文件 myfile 中查找包含字符串 mystr的行 grep -n mystr myfile 显示 myfile 中第一个字符为字母的所有行 grep ‘^[a-zA-Z]’ myfile 在文件 myfile 中查找首字符不是 # 的行（即过滤掉注释行） grep -v ‘^#’ myfile 列出/etc目录（包括子目录）下所有文件内容中包含字符串“root”的文件名 grep -lr root /etc/* Shell变量 和 Shell环境Shell 变量大致可以分为三类： 内部变量：由系统提供，用户只能使用不能修改。 ? GROUPS 环境变量：这些变量决定了用户工作的环境，它们不需要用户去定义，可以直接在 shell 中使用，其中某些变量用户可以修改。 用户变量：由用户建立和修改，在 shell 脚本编写中会经常用到。 变量赋值（定义变量） varName=Value export varName=Value 引用变量$varName Shell变量的作用域： 局部变量的作用范围仅仅限制在其命令行所在的Shell或Shell脚本文件中； 全局变量的作用范围则包括本Shell进程及其所有子进程。 局部变量与全局变量互换：可以使用 export 内置命令将局部变量设置为全局变量。可以使用 export 内置命令将全局变量设置为局部变量。 export命令： 显示当前Shell可见的全局变量 export [-p] 定义变量值的同时声明为全局变量。 export &lt;变量名1=值1&gt; [&lt;变量名2=值2&gt; …] 声明已经赋值的某个（些）局部变量为全局变量。 export &lt;变量名1&gt; [&lt;变量名2&gt; …] 声明已经赋值的某个（些）全局变量为局部变量。 export -n &lt;变量名1&gt; [&lt;变量名2&gt; …] Shell环境变量： 环境变量定义 Shell 的运行环境，保证 Shell 命令的正确执行。 Shell用环境变量来确定查找路径、注册目录、终端类型、终端名称、用户名等。 所有环境变量都是全局变量（即可以传递给 Shell 的子进程），并可以由用户重新设置。 Shell变量：查询、显示和取消： 显示当前已经定义的所有变量 所有环境变量：env 所有变量和函数（包括环境变量） ：set 显示某（些）个变量的值 echo $NAME1 [$NAME2 ……] 取消变量的声明或赋值 unset VI编辑器vi 是 “Visual interface” 的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。 普通模式 G用于直接跳转到文件尾 ZZ用于存盘退出Vi ZQ用于不存盘退出Vi /和？用于查找字符串 n继续查找下一个 yy复制一行 p粘帖在下一行，P粘贴在前一行 dd删除一行文本 x删除光标所在的字符 u取消上一次编辑操作（undo） 插入模式 在 Normal 模式下输入插入命令 i、 a 、 o进入insert模式。用户输入的任何字符都被vim当做文件内容保存起来，并将其显示在屏幕上。 在文本输入过程中，若想回到Normal模式下，按 Esc 键即可。 命令行模式 Normal 模式下，用户按冒号 :即可进入 Command 模式，此时 vim 会在显示窗口的最后一行 (屏幕的最后一行) 显示一个 “:” 作为 Command 模式的提示符，等待输入命令。 :w 保存当前编辑文件，但并不退出 :w newfile 存为另外一个名为 “newfile” 的文件 :wq 用于存盘退出Vi :q! 用于不存盘退出Vi :q用于直接退出Vi （未做修改） 设置Vi环境: :set autoindent 缩进,常用于程序的编写 :set noautoindent 取消缩进 :set number 在编辑文件时显示行号 :set nonumber 不显示行号 :set tabstop=value 设置显示制表符的空格字符个数 :set 显示设置的所有选项 :set all 显示所有可以设置的选项]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门学习笔记]]></title>
    <url>%2F2019%2F05%2F29%2FGit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[git - 简易指南 廖雪峰教程 Git官网 Git必看书籍:Pro Git Git：分布式版本控制系统Git是版本控制系统，Github是在线的基于Git的代码托管服务。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。 集中式和分布式的区别集中式：CVS、SVN 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库。和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 时光穿梭机版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 1234$ mkdir learngit //选择一个合适的地方，创建一个空目录$ cd learngit$ pwd$ git init //这个目录变成Git可以管理的仓库 当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的,如果要真正使用版本控制系统，就要以纯文本方式编写文件。因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 添加文件到Git仓库，分两步： 123$ git add readme.txt //注意，可反复多次使用，添加多个文件；$ git commit -m &quot;wrote a readme file&quot;$ cat readme.txt //读取文件内容 要随时掌握工作区的状态，使用git status命令。如果git status告诉你有文件被修改过，用git diff可以查看修改内容。在Git中，我们用git log命令查看。 123git statusgit diff readme.txtgit log 版本回退Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 123$ git reset --hard HEAD^$ git reset --hard deb9275$ git reflog 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区工作区（Working Directory）,就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 Git 有三种状态——已提交（committed）、已修改（modified）和已暂存（staged） 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 管理修改Git管理的是修改，而不是文件每次修改，如果不用git add到暂存区，那就不会加入到commit中。 撤销修改在准备提交前，猛然发现了错误,发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。 1$ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令. 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 先添加一个新文件test.txt到Git并且提交，git add test.txt，git commit -m “add test.txt”，直接在文件管理器中把没用的文件删了： 1234567$ rm test.txt //工作区已经把该文件删除//下一步分为两种情况：//（1）如果删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout -- test.txt //注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！//（2）确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit$ git rm test.txt$ git commit -m &quot;remove test.txt&quot; 远程仓库github：提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。本地Git仓库和GitHub仓库之间的传输是通过SSH加密，具体做法参考我的csdn博客。 在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，操作步骤为： 123456git remote add origin https://github.com/swhaleDCC/learn.git//添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上：git push -u origin master//用git push命令，实际上是把当前分支master推送到远程,由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令//从现在起，只要本地作了提交，就可以通过命令：git push origin master Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理创建与合并分支一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点: 123456789101112131415161718192021222324//创建dev分支，然后切换到dev分支:$ git checkout -b dev//加上-b参数表示创建并切换，相当于以下两条命令：$ git branch dev$ git checkout dev//用git branch命令查看当前分支：$ git branch//然后，我们在dev分支上正常提交//现在，dev分支的工作完成，我们就可以切换回master分支：$ git checkout master//现在，我们把dev分支的工作成果合并到master分支上：$ git merge dev //git merge命令用于合并指定分支到当前分支//删除分支$ git branch -d dev//总结：查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。git status可以告诉我们冲突的文件，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改后再提交，用带参数的git log可以看到分支的合并情况： 1$ git log --graph --pretty=oneline --abbrev-commit 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log –graph命令可以看到分支合并图。 分支管理策略–no-ff方式的git merge:通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作小结： 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。Rebaserebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 标签管理创建标签1234$ git tag v1.0$ git tag //查看所有标签$ git show v1.0 //查看标签信息$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //创建带有说明的标签，用-a指定标签名，-m指定说明文字 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了。 12$ git log --pretty=oneline --abbrev-commit$ git tag v0.9 f52c633 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签1234567$ git tag -d v0.1 //删除标签，因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除$ git push origin &lt;tagname&gt; //推送某个标签到远程$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签//如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v0.9//然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin :refs/tags/v0.9 码云国内的Git托管服务——码云 自定义Git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
