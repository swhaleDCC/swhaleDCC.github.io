title: 2018年力扣高频算法面试题(9)树
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 20:20:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->

#### 二叉搜索树中第K小的元素

> 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k个最小的元素。
假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？
解题思路：利用find记录是否找到结果，来提前终止遍历过程, https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/c-zhong-xu-bian-li-ti-jie-by-da-li-wang/ 。
![upload successful](/images/pasted-93.png)
为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。

```
class Solution {
public:
    int res=-1;
    void dfs(TreeNode* root, bool& find, int& i, int k) {
        if (root == NULL || find) return;
        dfs(root->left, find, i, k);
        if (++i == k) {
            res = root->val;
            find = true;
            return;
        }
        dfs(root->right, find, i, k);
    }
    int kthSmallest(TreeNode* root, int k) {
        bool find = false;
        int i = 0;
        dfs(root,find, i, k);
        return res;
    }
};
```

***

补充：

#### 路径总和
>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
解答：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/
最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。
![upload successful](/images/pasted-94.png)

```
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==NULL)return false;
        sum-=root->val;
        if(root->left==NULL && root->right==NULL)return sum==0;
        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);
    }
};
```

