title: 2018年力扣高频算法面试题(9)树
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 20:20:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->

#### 1、二叉搜索树中第K小的元素

> 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k个最小的元素。
假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？
解题思路：利用find记录是否找到结果，来提前终止遍历过程, https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/c-zhong-xu-bian-li-ti-jie-by-da-li-wang/ 。
![upload successful](/images/pasted-93.png)
为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。

```
class Solution {
public:
    int res=-1;
    void dfs(TreeNode* root, bool& find, int& i, int k) {
        if (root == NULL || find) return;
        dfs(root->left, find, i, k);
        if (++i == k) {
            res = root->val;
            find = true;
            return;
        }
        dfs(root->right, find, i, k);
    }
    int kthSmallest(TreeNode* root, int k) {
        bool find = false;
        int i = 0;
        dfs(root,find, i, k);
        return res;
    }
};
```
