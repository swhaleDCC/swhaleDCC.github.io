title: 2018年力扣高频算法面试题(9)树
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 20:20:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->

#### 二叉搜索树中第K小的元素

> 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k个最小的元素。
假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？
解题思路：利用find记录是否找到结果，来提前终止遍历过程, https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/c-zhong-xu-bian-li-ti-jie-by-da-li-wang/ 。
![upload successful](/images/pasted-93.png)
为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。

```
class Solution {
public:
    int res=-1;
    void dfs(TreeNode* root, bool& find, int& i, int k) {
        if (root == NULL || find) return;
        dfs(root->left, find, i, k);
        if (++i == k) {
            res = root->val;
            find = true;
            return;
        }
        dfs(root->right, find, i, k);
    }
    int kthSmallest(TreeNode* root, int k) {
        bool find = false;
        int i = 0;
        dfs(root,find, i, k);
        return res;
    }
};
```

***

补充：

#### 路径总和
>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
解答：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/
最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。
![upload successful](/images/pasted-94.png)

```
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==NULL)return false;
        sum-=root->val;
        if(root->left==NULL && root->right==NULL)return sum==0;
        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);
    }
};
```

#### 翻转二叉树
>翻转一棵二叉树。

>方法一：递归
![upload successful](/images/pasted-95.png)

```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)return root;
        TreeNode* right=invertTree(root->right);
        TreeNode* left=invertTree(root->left);
        root->right=left;
        root->left=right;
        return root;
    }
};
```

>方法二：迭代
我们需要交换树中所有节点的左孩子和右孩子。因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。开始的时候，只有根节点在这个队列里面。只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。
![upload successful](/images/pasted-96.png)
链接：https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode/

```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)return root;
        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty())
        {
            TreeNode* head=q.front();
            q.pop();
            TreeNode* tmp=head->left;
            head->left=head->right;
            head->right=tmp;
            if(head->left)q.push(head->left);
            if(head->right)q.push(head->right);
        }
        return root;
    }
};
```