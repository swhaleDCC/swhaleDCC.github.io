title: 2018年力扣高频算法面试题(8)排序与检索
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 20:19:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->

#### 1、寻找峰值

> 峰值元素是指其值大于左右相邻值的元素。
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞。
>要求：你的解法应该是O(logN)时间复杂度的。
>参考思路：
方法一：线性扫描：时间复杂度O(n)，空间复杂度O(1)。
方法二：二分查找：O(logN)时间复杂度。

```
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int right=nums.size()-1, left=0,m;
        while(left<right)
        {
            m=(right+left)/2;
            if(nums[m+1]<nums[m])right=m;
            else left=m+1;
        }
        return left;
    }
};
```

#### 2、寻找重复数
>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
>要求：不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。
>解答：
鸽子洞原理/抽屉原理：有ｎ只鸽子和ｍ个鸽洞，所有鸽子都住在鸽洞里，如果ｎ＞ｍ，那么至少有2只鸽子必须住在同一鸽洞里。
https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/

```
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow=0,fast=0;
        slow=nums[slow];
        fast=nums[nums[fast]];
        while(slow!=fast)
        {
            slow=nums[slow];
            fast=nums[nums[fast]];
        }
        int pre1=0,pre2=slow;
        while(pre1!=pre2)
        {
            pre1=nums[pre1];
            pre2=nums[pre2];
        }
        return pre1;
    }
};
```