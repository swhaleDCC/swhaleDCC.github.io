title: 2018年力扣高频算法面试题(8)排序与检索
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 20:19:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->

#### 1、寻找峰值

> 峰值元素是指其值大于左右相邻值的元素。
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞。
>要求：你的解法应该是O(logN)时间复杂度的。
>参考思路：
方法一：线性扫描：时间复杂度O(n)，空间复杂度O(1)。
方法二：二分查找：O(logN)时间复杂度。

```
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int right=nums.size()-1, left=0,m;
        while(left<right)
        {
            m=(right+left)/2;
            if(nums[m+1]<nums[m])right=m;
            else left=m+1;
        }
        return left;
    }
};
```

#### 2、寻找重复数
>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
>要求：不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。
>解答：
鸽子洞原理/抽屉原理：有ｎ只鸽子和ｍ个鸽洞，所有鸽子都住在鸽洞里，如果ｎ＞ｍ，那么至少有2只鸽子必须住在同一鸽洞里。
https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/

```
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow=0,fast=0;
        slow=nums[slow];
        fast=nums[nums[fast]];
        while(slow!=fast)
        {
            slow=nums[slow];
            fast=nums[nums[fast]];
        }
        int pre1=0,pre2=slow;
        while(pre1!=pre2)
        {
            pre1=nums[pre1];
            pre2=nums[pre2];
        }
        return pre1;
    }
};
```

#### 3、计算右侧小于当前元素的个数
>给定一个整数数组nums，按要求返回一个新数组counts。数组counts有该性质：counts[i]的值是nums[i]右侧小于nums[i]的元素的数量。
>解答：归并排序 + 索引数组
https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/

```
class Solution {
    vector<int>index;
    vector<int>helper;
    vector<int>count;
public:
    void merge(const vector<int> &nums,int lo,int mi,int hi)
    {
        if(lo==mi)return ;
        if(mi==hi)return ;
        // 先merge两个小的
        merge(nums, lo, (lo + mi) >> 1, mi);
        merge(nums, mi, (mi + hi) >> 1, hi);
        
        // 把需要用的index拷贝到helper里面，一会儿直接往index里面写就好了
        for (int k = lo; k < hi; k++) helper[k] = index[k];
        
        // 合并两个有序数组，并计算向右移动的位数(即右边有几个比当前元素小)
        int p1 = lo, p2 = mi, p = lo;
        while (p1 != mi or p2 != hi) {
            if (p1 == mi) {
                index[p++] = helper[p2++];
                
            } else if (p2 == hi) {
                index[p++] = helper[p1++];
                count[index[p - 1]] += (p2 - mi);  // p2 - mi即右边出了多少个
                
            } else if (nums[helper[p2]] < nums[helper[p1]]) {
                index[p++] = helper[p2++];
                
            } else {
                index[p++] = helper[p1++];
                count[index[p - 1]] += (p2 - mi);  // p2 - mi即右边出了多少个
            }
        }
    }
    
    vector<int> countSmaller(vector<int>& nums) {
        int len=nums.size();
        if(len==0)return {};
        if(len==1)return {0};
        
        index.resize(len);
        helper.resize(len);
        count.resize(len);
        
        for(int i=0;i<len;i++)
        {
            index[i]=i;
            count[i]=0;
        }
        
        //merge
        merge(nums,0,len/2,len);
        
        return count;
    }
};
```