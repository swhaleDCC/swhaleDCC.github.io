title: 2018年力扣高频算法面试题(2)图论
author: Dccun
tags:
  - LeetCode刷题笔记
categories:
  - 算法
date: 2019-07-28 17:07:00
---
![leetcode](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzczdDFiamVoMUJGM29kQ2YvaXQvdT00MTcyNTQ4MTE1LDExOTA2MDYwMzYmZm09ODUmcz0yQjQ1M0E2QTg1NDYyNkY1NTVFQzdDMDgwMDAwRTA5MA#pic_center)

<!--more-->


#### 课程表【需二刷】
>现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

```
//广搜
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        
        vector<vector<int> > graph(numCourses, vector<int>());
        vector<int> in(numCourses);
        
        for (auto a : prerequisites)
        {
            graph[a[1]].push_back(a[0]);  //有向图从a[1]指向a[0]
            ++in[a[0]];   //一维数组 in 来表示每个顶点的入度
        }
        
        queue<int> q;   
        for (int i = 0; i < numCourses; ++i) 
        {
            if (in[i] == 0) q.push(i);   //入度为0的课程，即没有先修课程的课程
        }
        
        //将所有入度为0的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为0，则说明环存在，返回 false，反之则返回 true。
        while (!q.empty())   
        {
            int t = q.front(); 
            q.pop();
            for (auto a : graph[t]) {
                --in[a];
                if (in[a] == 0) q.push(a);
            }
        }
        for (int i = 0; i < numCourses; ++i) 
        {
            if (in[i] != 0) return false;
        }
        return true;
    }
};

//深搜
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        //先建立好有向图，然后从第一门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用 DFS 递归，直到出现新的课程已经访问过了，则返回 false，没有冲突的话返回 true，然后把标记为已访问的课程改为未访问
        
        vector<vector<int>> graph(numCourses, vector<int>()); //有向图
        vector<int> visit(numCourses); // 记录访问状态，0表示还未访问过，1表示已经访问了，-1 表示有冲突
        for (auto a : prerequisites) 
        {
            graph[a[1]].push_back(a[0]);
        }
        for (int i = 0; i < numCourses; ++i) 
        {
            if (!canFinishDFS(graph, visit, i)) return false;
        }
        return true;
    }
    bool canFinishDFS(vector<vector<int>>& graph, vector<int>& visit, int i) {
        if (visit[i] == -1) return false;
        if (visit[i] == 1) return true;
        visit[i] = -1;
        for (auto a : graph[i]) {
            if (!canFinishDFS(graph, visit, a)) return false;
        }
        visit[i] = 1;
        return true;
    }
};
```

#### 课程表II【需二刷】
>现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
分析：bfs或者dfs进行拓扑排序，此题正是基于之前解法的基础上稍加修改，我们从 queue中每取出一个数组就将其存在结果中，最终若有向图中有环，则结果中元素的个数不等于总课程数，那我们将结果清空即可。

```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> res;
        vector<vector<int> > graph(numCourses, vector<int>(0));
        vector<int> in(numCourses, 0);
        
        for (auto a : prerequisites) {
            graph[a[1]].push_back(a[0]);  //有向图从a[1]指向a[0]
            ++in[a[0]];   //一维数组 in 来表示每个顶点的入度
        }
        
        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (in[i] == 0) q.push(i);
        }
        
        while (!q.empty()) {
            int t = q.front();
            res.push_back(t);
            q.pop();
            for (auto &a : graph[t]) {
                --in[a];
                if (in[a] == 0) q.push(a);
            }
        }
        if (res.size() != numCourses) res.clear();
        return res;
    }
};
```

#### 岛屿数量
>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
这个题我用的广搜，代码如下

```
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int res=0;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]=='1')
                {
                    res++;
                    bfs(grid,i,j);
                }      
            }
        }
        return res;
    }
    //以x，y为起点进行广搜
    void bfs(vector<vector<char>>& grid,int x,int y)
    {      
        int xx[]={0,0,1,-1};
        int yy[]={1,-1,0,0};
        
        queue<pair<int,int> >q;
        q.push(make_pair(x,y));
        
        while(!q.empty())
        {
            pair<int,int>p=q.front();
            q.pop();
            for(int i=0;i<4;i++)
            {
                int zx=p.first+xx[i];
                int zy=p.second+yy[i];
                if(zx<0||zx>=grid.size()||zy<0||zy>=grid[0].size()||grid[zx][zy]=='0')continue;
                grid[zx][zy]='0';
                q.push(make_pair(zx,zy));
            }
        }
    }
};
```

#### 单词接龙【需二刷】
>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
	每次转换只能改变一个字母。
	转换过程中的中间单词必须是字典中的单词。
说明:
	如果不存在这样的转换序列，返回 0。
	所有单词具有相同的长度。
	所有单词只由小写字母组成。
	字典中不存在重复的单词。
	你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
分析：BFS：我们需要一个队列queue，把起始单词排入队列中，开始队列的循环，取出队首词，然后对其每个位置上的字符，用26个字母进行替换，如果此时和结尾单词相同了，就可以返回取出词在哈希表中的值加一。如果替换词在字典中存在但在哈希表中不存在，则将替换词排入队列中，并在哈希表中的值映射为之前取出词加一。如果循环完成则返回0
	
```
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
	set<string>wordset(wordList.begin(),wordList.end());
	if(!wordset.count(endWord))return 0;
	
	map<string,int>pathcnt{{{beginWord,1}}};
	queue<string>q{{beginWord}};
	
	while(!q.empty())
	{
		string word=q.front();
		q.pop();
		for(int i=0;i<word.size();i++)
		{
			string newword=word;
			for(char ch='a';ch<='z';ch++)
			{
				newword[i]=ch;
				if(wordset.count(newword)&&newword==endWord)return pathcnt[word]+1;
				if(wordset.count(newword)&&!pathcnt.count(newword))
				{
					q.push(newword);
					pathcnt[newword]=pathcnt[word]+1;
				}
			}
		}
	}
	return 0;
}
```

#### Path Sum III
>You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

```
class Solution {
public:
    
    int helper(TreeNode* root, int sum){
        if(root == NULL)
            return 0;
        
        int cnt = 0;
        if(root->val == sum)
            cnt++;
        return cnt + helper(root->left,sum - root->val) +  helper(root->right,sum - root->val);
    }
    
    int pathSum(TreeNode* root, int sum) {
        if(root == NULL)
            return 0;
        
        return helper(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum);
    }
};
```